# 그림으로 쉽게 배우는 운영체제

## 운영체제  
개인 컴퓨터: Windows, MacOS  
대형 컴퓨터나 서버용: 유닉스, 리눅스  
스마트폰, 태블릿: 안드로이드,iOS -> 애플리케이션 설치  
네비게이션, 스마트워치, 냉장고, 세탁기 등: 임베디드 운영체제  
* 운영체제 없이도 동작은 가능하지만 운영체제가 없으면 다른 기능을 추가할 수 없음  

## 운영체제의 역할  
1. 프로세스 관리: 동시 실행 가능(백그라운드 실행)
2. 메모리 관리
3. 하드웨어 관리: 사용자가 하드웨어에 직접 접근하지 못하게 막음  
    - 중요한 데이터가 있을 수 있고 사용자가 악의적으로 공격할 수 있기 때문
4. 파일 시스템 관리: 많은 파일의 효율적인 저장과 관리를 위한 방법

## 운영체제의 역사 - 운영체제 구조  
### 1940년 에니악  
    미사일 탄도 계산을 위해 만들어진 컴퓨터이고 세계에서 가장 큰 스케일의 전자 디지털 계산기  
### 1950년도 초 직접회로  
    진공관과 전선으로 만들어진 논리회로를 아주 작은 크기로 만듬  
### 1950년도 중후반 싱글 스트림 배치 시스템  
    프로그래머가 펀치카드를 가져오면 여러 개를 한번에 컴퓨터에 전달해주고 컴퓨터는 여러 개의 프로그램을 순서대로 실행해서 결과도 한번에 확인할 수 있도록 개발  
    -> 입출력 속도가 느리고 입출력 도중 계산 불가  
    → CPU가 기다리느라 효율성이 떨어짐.
    -> ### I/O 디바이스 컨트롤러  
       - 입출력 작업이 끝나면 CPU에게 작업 완료 신호를 주고 신호를 받은 CPU가 처리하는 방식으로 발전하여 입출력 중에도 CPU가 계산할 수 있게 만듬  
       - 입력은 기다려야 해서 CPU 사용률이 떨어짐  
       - 출력의 경우 CPU가 종속적이지 않기 때문에 기다리지 않음  
       - CPU는 기다리지 않고 다른 작업을 하다가 작업완료 신호가 발생하면 필요한 처리를 진행함
### 1960년도 시분할 시스템   
- 메모리에 여러 개의 프로그램을 올려 놓고 시간을 나눠서 실행  
- 여러 사용자가 하나의 컴퓨터를 두고 터미널이라는 단말기를 통해 접근 -> 개인정보 등록 -> 파일시스템 등장  
### UNIX  
프로그램을 동시에 여러 개 실행시키는 멀티 프로그래밍, 여러 사용자를 지원하는 '다중 사용자', 파일을 관리하는 '파일시스템'을 구현한 운영체제
### 1960년대
1. 메모리 침범 이슈
2. 자신의 메모리 위치를 찾기 어려움  
- 기존에는 프로그램을 작성할 때 하나의 메모리에 하나의 프로그램이 있기 때문에 메모리 주소가 하나라고 가정하고 프로그래밍했는데 메모리가 여러 개 올라가면서 자기 위치를 찾기 어려워짐
-> ### 베이스 레지스터  
하드웨어적으로 '베이스 레지스터'를 추가하여 프로그램의 시작 주소를 저장하고 모든 프로그램은 0번지에서 실행한다고 가정  
### 1970년도 이후: 개인용 컴퓨터의 시대  
    ex. 애플의 매킨토시, 마이크로소프트의 MS-DOS


